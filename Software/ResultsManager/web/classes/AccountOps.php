<?php
require_once(dirname(__FILE__)."/SelectBuilder.php");
require_once(dirname(__FILE__)."/crypto/RSAKey.php");
require_once(dirname(__FILE__)."/crypto/Base8.php");

// gh#149
/*
$mypostfix = $neg_mypostfix = "";
for($i=0;$i<10;++$i) {
	if($i > 0) {
		$mypostfix .= ' AND';
		$neg_mypostfix .= ' OR';
	}
	$mypostfix .= " F_Prefix NOT LIKE '$i%'";
	$neg_mypostfix .= " F_Prefix LIKE '$i%'";
}

// Not sure why we allow one character in front of a number. This picks up R2ILM as a numeric prefix
//for($i=0;$i<10;++$i) {
//	$mypostfix .= " AND F_Prefix NOT LIKE '_$i%'";
//	$neg_mypostfix .= " OR F_Prefix LIKE '_$i%'";
//}

DEFINE('MYPOSTFIX', $mypostfix);
DEFINE('NEG_MYPOSTFIX', $neg_mypostfix);
*/

class AccountOps {

	var $db;
	
	private $dmsKey;
	private $orchidPublicKey;

	function AccountOps($db) {
		$this->db = $db;
		
		$this->copyOps = new CopyOps();
		$this->contentOps = new ContentOps($db);
		$this->manageableOps = new ManageableOps($db);
		
		// These key-pairs generated by OpenSSL. DK generated 256 bit key. 
		// It seems that I can only sign text that is shorter than the modulus of the key - which is 64bits.
		// So, lets not be too literal. You could sign a MD5 version of the full string.
		//$this->dmsKey = new RSAKey("00c9be86502ec265831d104f4f0ce071490aa0b707ac5ae2ac16306ba758368ee9", "10001", "573b03364e518db4f86f21ebab44ac96443df53a07a8e75ca24dcb42be0c2d05");
		$this->dmsKey = new RSAKey("a6f945c79fa1db830591618a0178f1ec4076436bd22e2c264de61b114eb78fad", "10001", "8fe751ce63b3b95dc854ad7da51b3953811b560d00d6a1248d91cff6a2976841");
		$this->orchidPublicKey = new RSAKey("00c2053455fe3c7c7b22a629d53ab2d98a2f46a2c403457da8d044116df9ab43fb", "10001");
	}

	/**
	 * If you changed the db, you'll need to refresh it here
	 * Not a very neat function...
	 */
	function changeDB($db) {
		$this->db = $db;
		$this->contentOps->changeDB($db);
		$this->manageableOps->changeDB($db);
	}
	 
	/**
	 * Bento specific function to getAccount details as need far less than RM and some RM bits are wrong
	 */
	function getBentoAccount($rootID, $productCode) {
		
		// gh#39 product code might be a comma delimited list. 
		// This is a small query, so no performance problems just doing the IN always.
		$sql = <<< SQL
				SELECT r.*, t.* 
				FROM T_AccountRoot r, T_Accounts t
				WHERE r.F_RootID = ?
				AND r.F_RootID = t.F_RootID
				AND t.F_ProductCode in ($productCode);
SQL;
		$bindingParams = array($rootID);
		$rs = $this->db->Execute($sql, $bindingParams);

		// gh#39 It would be an error to have more titles than the number of product codes
		$numProductCodes = substr_count($productCode, ',') + 1;
		
		// It would be an error to have more or less than one account
		// It would be an error to have more or less than one title in that account
		if ($rs->RecordCount() > $numProductCodes) {
			throw $this->copyOps->getExceptionForId("errorMultipleProductCodeInRoot", array("productCode" => $productCode));
		} else if ($rs->RecordCount() == 0) {
			throw $this->copyOps->getExceptionForId("errorNoProductCodeInRoot", array("productCode" => $productCode, "rootID" => $rootID));
		} 
		
		// Create the account object (just use the first record if multiple ones as they will all be the same account details)
		$dbObj = $rs->FetchObj();
		$account = $this->_createAccountFromObj($dbObj);
				
		// gh#39 You might have multiple matching titles
		while ($dbObj = $rs->FetchNextObj()) {
			$account->addTitles(array($this->_createTitleFromObj($dbObj)));
		}
				
		return $account;
	}
	
	/**
	 * Get the accounts.  If $accountIDArray is specified then only get those accounts, otherwise get them all.
	 * If onExpiryDate is specified then only accounts expiring on that day will be found.
	 * AR v3.1 This needs to be extended to get accounts based on lots of different criteria, not just expiryDate.
	 * Which must be similar to search I suppose. Except that that is all done by filtering on a dataGrid.
	 * So I need to use something like SelectBuilder and a set of conditions set in an array.
	 */
	//function getAccounts($accountIDArray = null, $onExpiryDate = null) {
	function getAccounts($accountIDArray = null, $conditions = null, $sortOrder = null) {

		// Get each account root that has at least one account expiring on this date
		// This SQL is written to return a row for each title in the accounts. I think this is wrong, it
		// should return only those titles that match the conditions.
		// Also changed so that we only get distinct roots back from this call.
		//$sql  = "SELECT ".Account::getSelectFields($this->db)." ";
		$selectBuilder = new SelectBuilder();	
		$needsAccountsTable = false;
		
		//$where = array();
		
		// Uncomment this line to only display accounts beginning with the letter A - makes it faster to developer :)
		//if (isset($_SESSION['justClarity'])) {
		//	$selectBuilder->addWhere('F_Name LIKE \'Clarity%\'');
		//}
		// If I don't want to see any accounts created by online subscription - filter on prefix (get rid of numeric ones)
		//NetDebug::trace("GLOBALS['onlineSubs']=".$GLOBALS['onlineSubs']);
		// Let this be a DMS interface switch
		//if ($GLOBALS['onlineSubs']) {
		//	$selectBuilder->addWhere('F_Prefix NOT LIKE \'%[^0-9]%\'');
		//} else {
		//	$selectBuilder->addWhere('F_Prefix LIKE \'%[^0-9]%\'');
		//}
		//$accountIDArray = array(13292, 13293, 13294);
		
		if ($accountIDArray) {
			if (isset($conditions['excludeRootIDs']) && $conditions['excludeRootIDs']=='true') {
				$selectBuilder->addWhere("a.F_RootID NOT IN (".join($accountIDArray, ",").")");
			} else {
				$selectBuilder->addWhere("a.F_RootID IN (".join($accountIDArray, ",").")");
			}
		}
		
		if (sizeof($conditions) > 0) {
			foreach ($conditions as $condition => $value) {
				//NetDebug::trace("condition=$condition=$value");
				//echo "condition=$condition=$value<br/>";
				switch ($condition) {
					case 'individuals':
						// gh#149
						// gh#385 Ignore for sqlite as we don't plan running DMS there
						// gh#403
						if (stristr($GLOBALS['dbms'],'sqlite') === FALSE) {
							if ($value == 'true') {
								//$selectBuilder->addWhere(NEG_MYPOSTFIX);
								$selectBuilder->addWhere("a.F_Prefix REGEXP '^[0-9]+$'");
							} else {
								//$selectBuilder->addWhere(MYPOSTFIX);
								$selectBuilder->addWhere("NOT (a.F_Prefix REGEXP '^[0-9]+$')");
							}
						}
						break;
					case 'archived':
						if ($value) {
							$selectBuilder->addWhere("a.F_AccountStatus = '11'");
						} else {
							$selectBuilder->addWhere("a.F_AccountStatus != '11'");
						}
						break;
					case 'expiryDate':
						//echo "expiryDate set to $value";
						//$where[] = "t.F_ExpiryDate = '".$onExpiryDate."'";
						// v3.3 Problem here in that expiry date in the db contains a time, whereas the value I am passing doesn't
						// I can either add '23:59:59' to the end on teh grounds that this is when all accounts should end
						// Or I can do a double condition to cover all day.
						// TODO: I think that MySQL wants DATE_ADD as the function name. adodb will surely help me.
						//	$selectBuilder->addWhere("t.F_ExpiryDate < DATEADD(Day,1,'".$value."')");
						// Or do it like this:
						if ($value != null) {
							$selectBuilder->addWhere("t.F_ExpiryDate >= '".substr($value,0,10)." 00:00:00'");
							$selectBuilder->addWhere("t.F_ExpiryDate <= '".substr($value,0,10)." 23:59:59'");
							$needsAccountsTable = true;
						}
						break;
					case 'licenceType':
						$selectBuilder->addWhere("t.F_LicenceType = '".$value."'");
						$needsAccountsTable = true;
						break;
					// v3.3 If I find I want this a lot, it would be better to build a general not function for all conditions
					case 'notLicenceType':
						$selectBuilder->addWhere("NOT t.F_LicenceType = '".$value."'");
						$needsAccountsTable = true;
						break;
					case 'accountType':
						$selectBuilder->addWhere("a.F_AccountType = '".$value."'");
						break;
					case 'customerType':
						// gh#1212 customerType is now a specific request
						//if ($value == 0) {
						//	$selectBuilder->addWhere("(a.F_CustomerType = 0 OR a.F_CustomerType is null)");
						//} else {
						//}
						$selectBuilder->addWhere("a.F_CustomerType = '".$value."'");
						break;
					case 'notCustomerType':
						$selectBuilder->addWhere("NOT a.F_CustomerType = '".$value."'");
						break;
					case 'accountStatus':
						$selectBuilder->addWhere("a.F_AccountStatus = '".$value."'");
						break;
					// The default is to ignore suspended accounts, don't send them anything
					case 'notAccountStatus':
						$selectBuilder->addWhere("NOT a.F_AccountStatus = '".$value."'");
						break;
					case 'productCode':
						// Note that this doesn't just find accounts that have this product, it ONLY returns this product in the accounts
						// Add comma delimited product code to help search for Road to IELTS
						if (stristr($value, ",")) {
							$selectBuilder->addWhere("t.F_ProductCode in (".$value.")");
						} else {
							$selectBuilder->addWhere("t.F_ProductCode = '".$value."'");
						}
						$needsAccountsTable = true;
						break;
					case 'notProductCode':
						// This should exclude these products from the account
						if (stristr($value, ",")) {
							$selectBuilder->addWhere("t.F_ProductCode not in (".$value.")");
						} else {
							$selectBuilder->addWhere("NOT t.F_ProductCode = '".$value."'");
						}
						$needsAccountsTable = true;
						break;
					// v3.4.3 This is a boolean - should it be string enclosed?
					// v3.6 AWS switch, data type is now tinyint, we want to treat it as boolean
					case 'selfHost':
						if ($value == 'true') {
							$selectBuilder->addWhere("a.F_SelfHost = 1");
						} else {
							$selectBuilder->addWhere("a.F_SelfHost = 0");
						}
						break;
					case 'deliveryFrequency':
						$selectBuilder->addWhere("t.F_DeliveryFrequency = '".$value."'");
						$needsAccountsTable = true;
						break;
						
					// gh#862
					case 'languageCode':
						$selectBuilder->addWhere("t.F_LanguageCode = '".$value."'");
						$needsAccountsTable = true;
						break;
						
					case 'active':
						if ($value == 'true') {
							$now = date('Y-m-d');
							$selectBuilder->addWhere("t.F_ExpiryDate >= '$now 00:00:00'");
							// Also add start date condition for 'active' accounts
							$selectBuilder->addWhere("t.F_LicenceStartDate <= '$now 23:59:59'");
							$needsAccountsTable = true;
						}
						// gh#911 If we are not specifically setting 'archived', then active means NOT archived
						if (!isset($conditions['archived']))
							$selectBuilder->addWhere("a.F_AccountStatus != '11'");
						break;
						
					// v3.5 Flexibility of email triggers. Ignore accounts that have opted out, for a while.
					case 'optOutEmails':
						$now = date('Y-m-d');
						$selectBuilder->addWhere("a.F_OptOutEmails = 0", true);
						$selectBuilder->addWhere("(a.F_OptOutEmails = 1 AND a.F_OptOutEmailDate < '$now 00:00:00')", true);
						$needsAccountsTable = true;
						break;
					// v3.6 Early Warning System
					case 'reseller':
					case 'resellerID':
						if (stristr($value, ",")) {
							$selectBuilder->addWhere("a.F_ResellerCode IN (".$value.")");
						} else {
							$selectBuilder->addWhere("a.F_ResellerCode = '".$value."'");
						}
						break;
					// v3.5 Subscription reminders need start date for first few emails - and they are only based on RM
					case 'startDate':
						//echo "startDate set to $value";
						if ($value != null) {
							$selectBuilder->addWhere("t.F_LicenceStartDate >= '".substr($value,0,10)." 00:00:00'");
							$selectBuilder->addWhere("t.F_LicenceStartDate <= '".substr($value,0,10)." 23:59:59'");
							$selectBuilder->addWhere("t.F_ProductCode=2");
							$needsAccountsTable = true;
						}
						break;
					// When you have a recurring day part of the date - also only applies to RM
					case 'startDay':
						//echo "startDay set to $value ";
						if ($value != null) {
							// Tested with MySQL, but not with SQLServer, though it should work
							//$selectBuilder->addWhere("DAYOFMONTH(t.F_LicenceStartDate) = $value");
							$buildDateString = $this->db->SQLDate('d','t.F_LicenceStartDate');
							$selectBuilder->addWhere("$buildDateString = $value");
							$selectBuilder->addWhere("t.F_ProductCode=2");
							$needsAccountsTable = true;
						}
						break;
					case 'accountName':
						//NetDebug::trace("condition=$condition=$value");
						// This is currently used only from DMS as a search. 
						// So it makes sense to assume we want to find this word anywhere in the name.
						// Add in a hack that lets you type in other search stuff too
						// It would make sense to actually parse this into regular conditions before you send it.
						if (substr($value,0,2)== 'P:') {
							$selectBuilder->addWhere("a.F_Prefix = '".substr($value,2)."'");
						} elseif (substr($value,0,2)== 'R:') {
							$selectBuilder->addWhere("a.F_RootID = '".substr($value,2)."'");
						} elseif (substr($value,0,2)== 'D:') {
							$selectBuilder->addWhere("a.F_ResellerCode = '".substr($value,2)."'");
						// gh#149
						} elseif (substr($value,0,6)== 'since:') {
							$selectBuilder->addWhere("t.F_LicenceStartDate >= '".substr($value,6)."'");
							$needsAccountsTable = true;
						} elseif (substr($value,0,3)== 'PC:') {
							$selectBuilder->addWhere("t.F_ProductCode = '".substr($value,3)."'");
							$needsAccountsTable = true;
						} else {
							if (stristr($value, '%') === FALSE) {
								$selectBuilder->addWhere("a.F_Name like '%$value%'");
							} else {
								$selectBuilder->addWhere("a.F_Name like '$value'");
							}
						}
						break;
				}
			}
		}
		// Build the from part
		//$sql  = "SELECT DISTINCT (a.F_RootID),".Account::getSelectFields($this->db)." ";
		$selectBuilder->addSelect('DISTINCT (a.F_RootID)');
		$selectBuilder->addSelect(Account::getSelectFields($this->db));
		//$sql .= "FROM T_AccountRoot a ";	
		$sqlFrom = "T_AccountRoot a ";	
		// Special handling for conditions that involve linking to other tables
		// If date ranges are defined then only get accounts with titles within that date range
		// This necessitates joining to the T_Accounts table. 
		// As does licenceType...
		if ($needsAccountsTable) $sqlFrom .= "LEFT JOIN T_Accounts t ON a.F_RootID=t.F_RootID ";
		$selectBuilder->setFrom($sqlFrom);
		
		//if (sizeof($where) > 0)
		//	$sql .= "WHERE ".implode(" AND ", $where)." ";
		
		// v3.4.3 Why wouldn't you order by root anyway?
		//if (!$accountIDArray) {
			//$sql .= "ORDER BY a.F_RootID DESC";
			//$sql .= "ORDER BY a.F_Name";
			// v3.4 Turns out that alphabetic isn't a great default order. For any kind of automated scripts
			// we need to order by root so we can start and stop at a particular place.
			//$selectBuilder->addOrder('a.F_Name');
			//$selectBuilder->addOrder('a.F_RootID');
			// You can choose other sort orders, such as expiry date
			//$selectBuilder->addSelect('t.F_ExpiryDate');
			//$selectBuilder->addOrder('t.F_ExpiryDate');
		//}
		if ($sortOrder==null) {
			$sortOrder = array('default');
		}
		foreach ($sortOrder as $order) {
			//NetDebug::trace("condition=$condition=$value");
			switch ($order) {
				case 'name':
					$selectBuilder->addOrder('a.F_Name');
					break;
				case 'expiryDate':
					$selectBuilder->addSelect('t.F_ExpiryDate');
					$selectBuilder->addOrder('t.F_ExpiryDate');
					break;
				default:
					$selectBuilder->addOrder('a.F_RootID');
			}
		}
			
		// Perform the query and create an array of Account objects from the results
		//echo "db=".$GLOBALS['db']."<br/>"; 
		//echo $selectBuilder->toSQL()."<br/>"; // exit(0);
		//NetDebug::trace("sql=".$selectBuilder->toSQL());

		//throw new Exception($selectBuilder->toSQL());
		$sql = $selectBuilder->toSQL();
		//NetDebug::trace($sql);
		//echo $sql;
		//$accountsRS = $this->db->Execute($selectBuilder->toSQL($sql)); 
		$accountsRS = $this->db->Execute($sql); 
		//NetDebug::trace("accounts=".$accountsRS->RecordCount());
		//echo "accounts=".$accountsRS->RecordCount();
		$result = array();
		
		if ($accountsRS->RecordCount() > 0) {
			while ($accountObj = $accountsRS->FetchNextObj()) {
				// Create the account object
				$account = $this->_createAccountFromObj($accountObj);
				
				// v3.3. Just to prevent warnings
				if (!isset($conditions['productCode'])) $conditions['productCode'] = null;
				if (!isset($conditions['expiryDate'])) $conditions['expiryDate'] = null;
				// Add the titles for this account (based on expiry date if desired)
				// Or should I get back all titles - which would be better for subscription reminders
				//$account->addTitles($this->contentOps->getTitles($account->id, $onExpiryDate));
				// v3.3 Confirm - we want all titles back, not just expiring ones. The reminder email can sort it out.
				//$account->addTitles($this->contentOps->getTitles($account->id, $conditions['expiryDate'], $conditions['productCode']));
				$account->addTitles($this->contentOps->getTitles($account->id, null, $conditions['productCode']));
				//$account->addTitles($this->contentOps->getTitles($account->id));
				
				// Get the admin user (if there is one) for this account and add it into the object
				if ($account->getAdminUserID()) {
					$account->adminUser = $this->manageableOps->getUserById($account->getAdminUserID());
				}
				
				// Get the licence attributes and add them them into the object
				// TODO this is a very slow call - about 14s from 500 accounts. Why?
				// Can I delay doing this until I want to edit an account? It is pretty rare anyway.
				//$account->licenceAttributes = $this->db->GetArray("SELECT F_Key licenceKey, F_Value licenceValue, F_ProductCode productCode FROM T_LicenceAttributes WHERE F_RootID=?", array($account->id));
				
				$result[] = $account;
			}
		}
		
		return $result;
	}
	
	/**
	 * Get the licence attributes for an account.
	 * v4.0 Allow productCode to be optionally specified 
	 */
	function getAccountLicenceDetails($accountID, $config=null, $productCode=null) {
		
		// Can I delay doing this until I want to edit an account? It is pretty rare anyway.
		$licenceAttributes = $this->db->GetArray("SELECT F_Key licenceKey, F_Value licenceValue, F_ProductCode productCode FROM T_LicenceAttributes WHERE F_RootID=?", array($accountID));
		if ($productCode && $licenceAttributes && count($licenceAttributes>0)) {
			$relevantAttributes = array();
			// If you set the productCode, then it means you want all null values, and any value that includes your pc in the list
			// I think this is going to be simplest to do post query.
			foreach ($licenceAttributes as $detail) {
				if ($detail['productCode']=='') {
					$relevantAttributes[] = $detail;
				} else {
					$codes = explode(',',$detail['productCode']);
					foreach ($codes as $code) {
						if ($code==$productCode) {
							$relevantAttributes[] = $detail;
							break;
						}
					}
				}
			}
		} else {
			$relevantAttributes = $licenceAttributes;
		}
		return $relevantAttributes;
	}
	
	/**
	 * This method returns the following dictionary dataProviders (for mapping ids to names):
	 * - accountStatus
	 * - approvalStatus
	 * - resellers
	 * - termsConditions
	 * - products
	 * - licenceTypes
	 */
	function getDictionary($dictionaryName) {
		//NetDebug::trace('AccountOps.getDictionary='.$dictionaryName);
		switch ($dictionaryName) {
			case "accountStatus":
				$result = $this->db->GetArray("SELECT F_Status data, F_Description label FROM T_AccountStatus");
				break;
			// v3.0.5 Change status handling
			//case "approvalStatus":
			//	return $this->db->GetArray("SELECT F_Status data, F_Description label FROM T_ApprovalStatus");
			case "accountType":
				$result = $this->db->GetArray("SELECT F_Type data, F_Description label FROM T_AccountType");
				break;
			case "customerType":
				$result = $this->db->GetArray("SELECT F_Type data, F_Description label FROM T_CustomerType");
				break;
			case "resellers":
				$result = $this->db->GetArray("SELECT F_ResellerID data, F_ResellerName label FROM T_Reseller order by F_DisplayOrder");
				break;
			case "termsConditions":
				$result = $this->db->GetArray("SELECT F_Status data, F_Description label FROM T_TermsConditions");
				break;
			case "products":
				// v3.3 Drop DefaultContentLocation from here - move to T_ProductLangauge
				//return $this->db->GetArray("SELECT F_ProductCode data, F_ProductName label, F_DefaultContentLocation defaultContentLocation 
				//$result = $this->db->GetArray("SELECT F_ProductCode data, F_ProductName label FROM T_Product");
				// v3.5 withing displayOrder, make it alphabetic
				$result = $this->db->GetArray("SELECT F_ProductCode data, F_ProductName label FROM T_Product order by F_DisplayOrder, F_ProductName");
				break;
			case "licenceType":
				$result = $this->db->GetArray("SELECT F_Status data, F_Description label FROM T_LicenceType");
				break;
			// v3.3 What I am really interested in is the languages that a particular title can use
			//case "languageCode":
			//	return $this->db->GetArray("SELECT F_LanguageCode data, F_Description label FROM T_Language");
			case "languageCode":
				$sql = <<< EOD
					SELECT P.F_LanguageCode data, L.F_Description label, P.F_ProductCode productCode
					FROM T_Language L, T_ProductLanguage P
					WHERE P.F_LanguageCode = L.F_LanguageCode
					ORDER BY P.F_ProductCode
EOD;
				return $this->db->GetArray($sql);
			case "versionCode":
				$sql = <<< EOD
					SELECT P.F_VersionCode data, V.F_Description label, P.F_ProductCode productCode
					FROM T_Version V, T_ProductVersion P
					WHERE P.F_VersionCode = V.F_VersionCode
					ORDER BY P.F_ProductCode
EOD;
				return $this->db->GetArray($sql);
			// gh#231
			case "loginOption":
				$result = $this->db->GetArray("SELECT F_Type data, F_Description label FROM T_LoginOption");
				break;
			case "selfRegisterOption":
				$result = $this->db->GetArray("SELECT F_Type data, F_Description label FROM T_SelfRegisterOption");
				break;
			default:
				throw new Exception("Unknown dictionary name '".$dictionaryName."'");
		}
		
		// as mysql result return only string no matter what the types defined in the database
		// manual conversion is done here
		for($i=0;$i<count($result);++$i) {
			$result[$i]['data'] = intval($result[$i]['data']);
		}
		return $result;
		
	}
	// Similarly to the dictionary, I want to be able to get the reseller email based on their ID
	function getResellerEmail($id) {
		$sql = <<< EOD
				SELECT *
				FROM T_Reseller
				WHERE F_ResellerID = $id
EOD;
		$rs = $this->db->Execute($sql);	
		if ($rs)
			return $rs->FetchNextObj()->F_Email;
	}
	
	function addAccount($account) {
		if (!$this->isAccountValid($account))
			// This account cannot be added (probably because it does not have a unique prefix)
			throw new Exception($this->copyOps->getCopyForId("prefixExistsError", array("prefix" => $account->prefix)));
		
		$this->db->StartTrans();
				
		// Create an entry in account root
		$this->db->AutoExecute("T_AccountRoot", $account->toAssocArray(), "INSERT");
		
		// Set the root id
		$account->id = $this->db->Insert_ID();
		AbstractService::$log->setRootID($account->id);
		//echo "new root=$account->id"."<br/>";
		
		// Now update the titles within the account
		// vCLS It is possible you are adding an account with no titles (because you will add the titles later)
		if (count($account->titles)>0) {
			$this->updateAccountTitles($account);
		}

		// gh#653 useful to know if this is a home user account
		if (count($account->titles) > 0 && $account->titles[0]->licenceType == Title::LICENCE_TYPE_I)
			$homeUser = true;
		
		// If an admin user is specified (as it always will be except with self-hosted accounts) then create a group and user
		if ($account->adminUser) {
			// Create and add a new group
			$group = new Group();
			$group->name = $account->name;
			$group = $this->manageableOps->addGroup($group);
			//echo "added group $group->id to root $account->id"."<br/>";
			
			// Create a new user, add them to the group then update adminUserID in $account with the newly added user id
			$adminUser = $this->manageableOps->addUser($account->adminUser, $group, $account->id);
			// Update the adminUserID field in the database to point at the newly created user
			$this->db->Execute("UPDATE T_AccountRoot SET F_AdminUserID=? WHERE F_RootID=?", array($adminUser->userID, $account->id));
			AbstractService::$controlLog->info("Created group name=".$account->name.", id=".$group->id.", and user name=".$account->adminUser->name.", id=".$account->adminUser->userID);
			
			// v3.7 Also create a learner user at the same time. Mostly useful for AA accounts.
			// gh#653 but skip this for home user sales as completely unnecessary
			if (!$homeUser) {
				$learnerUser = new User();
				$learnerUser->name = $account->prefix.'_learner';
				// gh#653 Must initialise all possible key fields
				$learnerUser->email = 'learner@'.$account->prefix.'.com';
				$learnerUser->studentID = $account->prefix.'_learner';
				$learnerUser->password = $account->prefix;
				$learnerUser->userType = User::USER_TYPE_STUDENT;
				$learnerUser = $this->manageableOps->addUser($learnerUser, $group, $account->id);			
				AbstractService::$controlLog->info("Created learner name=".$learnerUser->name.", id=".$learnerUser->userID);
			}
						
			// You need to add a record to T_AccountEmails for this admin user
			$dbObj = array();
			$dbObj['F_RootID'] = $account->id;
			$dbObj['F_AdminUser'] = 1;
			$dbObj['F_MessageType'] = 31;
			$this->db->AutoExecute("T_AccountEmails", $dbObj, "INSERT");			
		}
		
		// v3.2 This was not added for new accounts. Generally it is not set for new accounts.
		if (isset($account->licenceAttributes)) {
			foreach ($account->licenceAttributes as $licenceAttribute) {
				$dbObj = array();
				$dbObj['F_RootID'] = $account->id;
				$dbObj['F_Key'] = $licenceAttribute['licenceKey'];
				$dbObj['F_Value'] = $licenceAttribute['licenceValue'];
				if ($licenceAttribute['productCode'] > 0) $dbObj['F_ProductCode'] = $licenceAttribute['productCode'];
				$this->db->AutoExecute("T_LicenceAttributes", $dbObj, "INSERT");
			}
		}
			
		AbstractService::$controlLog->info("Created account name=".$account->name.", id=".$account->id.", by user=".Session::get('userID'));
		$this->db->CompleteTrans();
	}
	
	/**
	 * Update the given array of accounts in the database
	 * 
	 * @param accountsArray An array of Account objects
	 */
	function updateAccounts($accountsArray) {
		AbstractService::$log->setRootID($account->id);
		$this->db->StartTrans();
		
		foreach ($accountsArray as $account) {
			AbstractService::$controlLog->info("Update account name=".$account->name.", id=".$account->id.", by user=".Session::get('userID'));
			
			if (!$this->isAccountValid($account))
				// This account cannot be added (probably because it does not have a unique prefix)
				throw new Exception($this->copyOps->getCopyForId("prefixExistsError", array("prefix" => $account->prefix)));

			// First update the account root. This is failing because the account object has no loginOption.
			// getAccounts is sending back loginOption to DMS though. Seems we have to include it in the DetailsPane.
			//NetDebug::trace('AccountOps.updateAccounts loginOption='.$account->loginOption);
			$this->db->AutoExecute("T_AccountRoot", $account->toAssocArray(), "UPDATE", "F_RootID=".$account->id);
			
			// Then update the titles within the account
			$this->updateAccountTitles($account);
			
			// Update the admin user object if it exists
			if ($account->adminUser) $this->manageableOps->updateUsers(array($account->adminUser), $account->id);
			
			// Finally delete the licence attributes
			$this->db->Execute("DELETE FROM T_LicenceAttributes WHERE F_RootID=?", array($account->id));
			
			foreach ($account->licenceAttributes as $licenceAttribute) {
				$dbObj = array();
				$dbObj['F_RootID'] = $account->id;
				$dbObj['F_Key'] = $licenceAttribute['licenceKey'];
				$dbObj['F_Value'] = $licenceAttribute['licenceValue'];
				if ($licenceAttribute['productCode'] > 0) $dbObj['F_ProductCode'] = $licenceAttribute['productCode'];
				//NetDebug::trace('AccountOps.licenceAttribute insert '.$dbObj['F_Key'].'='.$dbObj['F_Value'].':'.$dbObj['F_ProductCode']);
				$this->db->AutoExecute("T_LicenceAttributes", $dbObj, "INSERT");
			}
		}
		
		$this->db->CompleteTrans();
	}
	
	function deleteAccounts($accountsArray) {
		$this->db->StartTrans();
		
		foreach ($accountsArray as $account) {
			//NetDebug::trace('AccountOps.deleteAccounts adminid='.$account->adminUser->id);
			if ($account->adminUser) {
				// Get the id of the top level group for this account
				// v3.4 Multi-group users
				//$rootGroupID = $this->manageableOps->getGroupIdForUserId($account->adminUser->id);
				$rootGroupID = $this->manageableOps->getGroupIdForUserId($account->adminUser->userID);
				//NetDebug::trace('AccountOps.deleteAccounts groupid='.$rootGroupID);
				
				// Get the managables for the top level group
				$group = $this->manageableOps->getManageables(array($rootGroupID), false);
				
				// Delete it (this will delete all sub users and groups including the admin user)
				// v3.0.6 But this fails... It is because getManageables already returns an array.
				//$this->manageableOps->deleteManageables(array($group));
				$this->manageableOps->deleteManageables($group);
				// Can I see what I have got for my manageables? Yes, Charles will show this.
				//return $group;
			}
			
			// Delete the titles associated with the root id
			$this->db->Execute("DELETE FROM T_Accounts WHERE F_RootID=?", array($account->id));
			
			// Delete any licence attributes
			$this->db->Execute("DELETE FROM T_LicenceAttributes WHERE F_RootID=?", array($account->id));
			
			// and any related emails
			$this->db->Execute("DELETE FROM T_AccountEmails WHERE F_RootID=?", array($account->id));
			
			// And finally delete the account itself
			$this->db->Execute("DELETE FROM T_AccountRoot WHERE F_RootID=?", array($account->id));
		}
		
		// make the root of the changed account explicit in the log
		AbstractService::$log->setRootID($account->id);
		AbstractService::$controlLog->info("Deleted account name=".$account->name.", id=".$account->id.", by user=".Session::get('userID'));
		
		$this->db->CompleteTrans();
	}
	
	/**
	 * Given an account object this deletes and then recreates all entries in T_Account for that account.  Used by add and update accounts.
	 */
	private function updateAccountTitles($account) {
	
		// v3.3 Can I do a validity check on the titles first?
		// For instance, the languageCode must be filled in
		// Then add in the new/updated titles
		foreach ($account->titles as $title) {
			if (!$this->isTitleValid($title))
				throw new Exception($this->copyOps->getCopyForId("mismatchedLanguageCode", array("productCode" => $title->productCode, "languageCode" => $title->languageCode)));
		}		
		// First delete any titles currently associated with this account
		//echo "updateAccountTitles for $account->id"."<br/>";
		$this->db->Execute("DELETE FROM T_Accounts WHERE F_RootID=?", array($account->id));
		
		$allLicencesAA = true;
		// Then add in the new/updated titles
		foreach ($account->titles as $title) {
			// v3.3 Before you create the checksum, make sure that the expiry date has been altered to 23:59:59
			$title->expiryDate = substr($title->expiryDate,0,10).' 23:59:59';
			$title->licenceStartDate = substr($title->licenceStartDate, 0, 10).' 00:00:00';
			
			// gh#987 Check that F_ProductVersion is not null
			if (!$title->productVersion)
				$title->productVersion = Title::FULL_VERSION;
				
			$titleArray = $title->toAssocArray();
			$titleArray["F_RootID"] = $account->id;
			$titleArray["F_Checksum"] = $this->generateChecksumForTitle($title, $account);
			//NetDebug::trace("root=".$account->id." productCode=".$title->productCode." checksum=".$titleArray["F_Checksum"]);
			$this->db->AutoExecute("T_Accounts", $titleArray, "INSERT");
			
			// v3.0.6 We need to create an Author Plus folder, if they are adding AP for the first time, and this is not self-hosted
			if ($title->productCode == 1 && !$account->selfHost) {
				// v3.5 Now dbContentLocation is tied to the field in DMS and is the direct database link
				//$thisContentLocation = $this->contentOps->getContentFolder($title->contentLocation, $title->productCode);
				$thisContentLocation = $this->contentOps->getContentFolder($title->dbContentLocation, $title->productCode);
				//NetDebug::trace('AccountOps.addAccount AuthorPlus folder='.$thisContentLocation);
				if (!is_dir($thisContentLocation)) {
					// v4.3 I sometimes get error suggesting that copy(../../../../../ap/../ap/templates_empty/course.xml) doesn't exist.
					// Is this path wrong here, or some strange data thing? I only see it on claritymain. I think it is wrong.
					//$emptyTemplate = $this->contentOps->getContentFolder("../ap/templates_empty", $title->productCode);
					$emptyTemplate = $this->contentOps->getContentFolder("templates_empty", $title->productCode);
					//NetDebug::trace('AccountOps.addAccount need to create the folder');
					// it doesn't exist, so create it
					mkdir($thisContentLocation, 0777);
					// Do we need to add any files to it, or are they created on first entry by Authoring?
					// Create a Courses folder and an empty course.xml
					mkdir($thisContentLocation."/Courses", 0777);
					if (!copy($emptyTemplate."/course.xml", $thisContentLocation."/course.xml")) {
						//NetDebug::trace('AccountOps.addAccount failed to copy '.$emptyTemplate.'/course.xml');
					}
					AbstractService::$log->setRootID($account->id);
					AbstractService::$controlLog->info(" created ap folder=".$thisContentLocation);
				}
			}

			// v3.4 We need to create a CCB folder, if they are adding AP for the first time, and this is not self-hosted
			if ($title->productCode == 54 && !$account->selfHost) {
				$thisContentLocation = $this->contentOps->getContentFolder($title->dbContentLocation, $title->productCode);
				if (!is_dir($thisContentLocation)) {
					mkdir($thisContentLocation, 0777);
					AbstractService::$log->setRootID($account->id);
					AbstractService::$controlLog->info(" created CCB folder=".$thisContentLocation);
				}
			}
			
			// v3.0.6 For any AA licences, add action=anonymous to the licence attributes, with a specific product code
			// Actually, no need as Orchid will automatically set AA licence to action=anonymous if nothing else is set.
			if ($title->licenceType == Title::LICENCE_TYPE_AA) {
				/*
				// We need to make sure we don't have this combination already to avoid duplicates, or indeed overwrite any 'action'
				$noDuplicates = true;
				foreach($account->licenceAttributes as $licenceRow) {
					//NetDebug::trace('AccountOps.licenceAttribute '.$licenceRow['licenceKey'].'='.$licenceRow['licenceValue'].':'.$licenceRow['productCode']);
					if ($licenceRow['licenceKey'] == 'action' && $licenceRow['productCode'] == $title-> productCode) {
						$noDuplicates = false;
						// update this row as we won't add a new one
						$licenceRow['licenceValue'] = 'anonymous';
						break;
					}
				}
				if ($noDuplicates) {
					NetDebug::trace('AccountOps.licenceAttribute add action=anonymous for '.$title-> productCode);
					$account->licenceAttributes[] = array( 'licenceKey' => 'action', 
														'licenceValue' => 'anonymous', 
														'productCode' => $title-> productCode );
				}
				*/
			} else {
				$allLicencesAA = false;
			}
			
			// gh#1190 Write control log
			switch ($title->licenceType) {
				case Title::LICENCE_TYPE_LT:
					$licenceTypeDescription = 'LT';
					break;
				case Title::LICENCE_TYPE_AA:
					$licenceTypeDescription = 'AA';
					break;
				case Title::LICENCE_TYPE_NETWORK:
					$licenceTypeDescription = 'Network';
					break;
				case Title::LICENCE_TYPE_SINGLE:
				case Title::LICENCE_TYPE_I:
					$licenceTypeDescription = 'Single';
					break;
				case Title::LICENCE_TYPE_TT:
					$licenceTypeDescription = 'TT';
					break;
				case Title::LICENCE_TYPE_CT:
					$licenceTypeDescription = 'LT';
					break;
				default:
					$licenceTypeDescription = 'unknown ';
					
			}
			AbstractService::$controlLog->info(" title ".$title->name." ".$licenceTypeDescription." licence=".$title->maxStudents." until ".$title->expiryDate);
		}
		// v3.0.6 If all the titles are AA licences, CE.com/shared will the portal they use for access.
		// This is signalled by adding 128 to the loginOption.
		//NetDebug::trace('AccountOps.updateAccounts original F_LoginOption='.$account->loginOption);
		// BUG: Orchid declarations shows that email login is 128. But old CLS accounts all have 65 or 64 as the loginOption
		// Since CLS/R2I don't ever login through CE.com, I suppose it won't matter if they use 128 as well. But it should be cleared up
		// For now I will remove the bit here there subtracts 128 if all titles are NOT AA
		if ($allLicencesAA) {
			$account->loginOption = $account->loginOption | 128; // make sure 128 is set
		//} else {
		//	$account->loginOption = ($account->loginOption | 128) ^ 128; // make sure 128 is not set
		}
		//NetDebug::trace('AccountOps.updateAccounts allAA='.$allLicencesAA.' so set F_LoginOption='.$account->loginOption);
		$this->db->Execute("UPDATE T_AccountRoot SET F_LoginOption=? WHERE F_RootID=?", array($account->loginOption, $account->id));
		//echo "updatedAccountTitles"."<br/>";
	}
	
	/**
	 * Go through all the titles in the account generating the checksum for each of them
	 */
	public function generateChecksumForTitle($title, $account) {
		// Note that the encoded hash ($m) must be <= to length of n in hex (32)
		// We want to protect the 
		// 	institution name (from T_AccountRoot)
		//	hosting domain (need to add to T_AccountRoot) -- but what would this be for network? Just empty I suppose.
		//	expiry date
		//	maxStudents
		//	licenceType
		//	rootID
		//	productCode
		//$protectedString = $account->name.$account->selfHostDomain.$title-> expiryDate.$title-> maxStudents.$title-> licenceType.$account->id.$title-> productCode;
		$protectedString = $account->name.$title-> expiryDate.$title-> maxStudents.$title-> licenceType.$account->id.$title-> productCode;
		$escapedString = $this->actionscriptEscape($protectedString);
		//$protectedString = "adrian raper's college of languagehttp://www.clarityenglish.com2009-12-10153138";

		//NetDebug::trace("checksum protected=$protectedString");
		//NetDebug::trace("escaped=$escapedString");
		// v6.5.5.5 because php and actionscript do md5 differently, we need to escape first
		$hash = md5($escapedString);
		//NetDebug::trace("hash=$hash");
		
		// Encode and sign the hash
		$m = Base8::encode($hash);
		//NetDebug::trace("checksum m=$m");
		$c = $this->dmsKey->sign($m);
		//NetDebug::trace("checksum c=$c");
		$c = $this->orchidPublicKey->encrypt($c);
		//NetDebug::trace("checksum=$c");
		//echo "checksum c=$c";
		
		return $c;
	}
	/*
	 * This reads all the email addresses for this account who are registered to receive this type of message
	 */
	public function getEmailsForMessageType($rootID, $msgType = null) {
		// If you don't pass a msgType, return all emails
		$bindingParams = array($rootID);
		// Remember that the admin email is NOT stored here, you have to get that from T_User
		// But there IS a record for the admin user storing rootID messageType and adminUser
		$sql = "SELECT u.F_Email FROM T_User u, T_AccountRoot a WHERE a.F_RootID=? AND u.F_UserID = a.F_AdminUserID";
		$rs = $this->db->Execute($sql, $bindingParams); 
		if ($rs)
			$adminUserEmail = $rs->FetchNextObj()->F_Email;
			
		// msgType from the table is sequential, but used as a binary flag in RM
		if (!is_null($msgType) && is_numeric(intval($msgType))) {
			$msgTypeFlag = pow(2,$msgType-1);
		}
		$sql = "SELECT F_Email, F_AdminUser FROM T_AccountEmails WHERE F_RootID=?";
		if (!is_null($msgType) && is_numeric(intval($msgType))) {
			$sql .= " AND F_MessageType&?";
			$bindingParams[] = intval($msgTypeFlag);
		}
		$accountsRS = $this->db->Execute($sql, $bindingParams); 
		$result = array();
		
		// gh#226 It is possible that T_AccountEmails doesn't have a record for this root
		// That indicates some kind of error, but we don't need to worry about it here
		if ($accountsRS->RecordCount() > 0) {
			while ($emailObj = $accountsRS->FetchNextObj()) {
				if ($emailObj->F_AdminUser) {
					$result[] = $adminUserEmail;
				} else {
					$result[] = $emailObj->F_Email;
				}
			}
		} else if ($accountsRS->RecordCount() == 0) {
			$result[] = $adminUserEmail;
		}
		return $result;
	}
	
	/*
	 * This is a simple version of ActionScript escape function
	 */
	private function actionscriptEscape($text) {
		$needles = array('_','-','.');
		$replaces = array('%5F','%2D','%2E');
		return str_replace($needles,$replaces,rawurlencode($text));
	}
	
	/*
	 * This method creates a new Account from an AdoDB object returned by FetchNextObject()
	 */
	private function _createAccountFromObj($dbObj) {
		$account = new Account();
		$account->fromDatabaseObj($dbObj);
		return $account;
	}
	/*
	 * This method creates a new Title from an AdoDB object returned by FetchNextObject()
	 */
	private function _createTitleFromObj($dbObj) {
		$title = new Title();
		$title->fromDatabaseObj($dbObj);
		return $title;
	}
	
	/**
	 * Determine if an account is valid.  An account is valid (i.e. can be updated / created) if its prefix is unique.
	 */
	private function isAccountValid($account) {
		// Ensure the prefix is unique (or empty if self-hosted)
		if ($account->selfHost) return true;
		$sql = 	<<<EOD
				SELECT F_RootID, F_Prefix
				FROM T_AccountRoot
				WHERE F_Prefix=?
EOD;
		$rs = $this->db->Execute($sql, array($account->prefix));
		
		switch ($rs->RecordCount()) {
			case 0:
				// There are no duplicates
				return true;
			case 1:
				// There is a duplicate, but if this is an update it might be the same record
				return ((int)($rs->FetchNextObj()->F_RootID) == (int)($account->id));
			default:
				// Something is wrong with the database!
				throw new Exception("isAccountValid: More than one account was returned with prefix '".$account->prefix."'");
		}
	}
	/**
	 * v3.3 Is this title Ok to save?
	 */
	private function isTitleValid($title) {
		// Ensure that the languageCode has a valid value
		$sql = 	<<<EOD
				SELECT *
				FROM T_ProductLanguage
				WHERE F_ProductCode=? 
				AND F_LanguageCode=?
EOD;
		$rs = $this->db->Execute($sql, array($title->productCode, $title->languageCode));
		
		switch ($rs->RecordCount()) {
			case 0:
				// There is no matching pair, raise an error
				return false;
			default:
		}
		// Also make sure that Author Plus has a content location
		// But how to differentiate this from the above error? 
		// Need to return an error code I suppose.
		// This is left for now. You get a double error message, but that is kind of OK
		// v3.5 Now dbContentLocation is tied to the field in DMS and is the direct database link
		//if ($title-> productCode == 1 && ($title->contentLocation == "" || $title->contentLocation == null))
		// Also CCB
		if (($title->productCode == 1 || $title->productCode == 54) && ($title->dbContentLocation == "" || $title->dbContentLocation == null))
			return false;
			
		return true;
	}

	/* 
	 * Functions to find an account based on key information
	 */
	// This one is for CLS accounts which have unique emails for the admin user
	public function getAccountFromEmail($email) {
	
		// gh#149
		//$sql .= ' AND ('.NEG_MYPOSTFIX.')';
		$sql = 	<<<EOD
				SELECT r.F_RootID rootID
				FROM T_AccountRoot r, T_User u
				WHERE r.F_AdminUserID = u.F_UserID
				AND u.F_Email = ?
				AND r.F_Prefix REGEXP '^[0-9]+$'
EOD;
		//echo $sql;
		$rs = $this->db->Execute($sql, array($email));
		
		switch ($rs->RecordCount()) {
			case 0:
				// There is no matching pair, raise an error
				return false;
				break;
			case 1:
				// One record, good. Send back the root
				$rootID = $rs->FetchNextObj()->rootID;
				break;
			default:
				return false;
		}
		
		// now get the account (just one)
		$accounts = $this->getAccounts(array($rootID));
		return array_shift($accounts);
	}
	
	// This one is for when you know the group that a user is in
	public function getAccountFromGroup($group) {
	
		$sql = 	<<<EOD
				SELECT DISTINCT(r.F_RootID) as rootID
				FROM T_AccountRoot r, T_Membership m
				WHERE r.F_RootID = m.F_RootID
				AND m.F_GroupID = ?
EOD;
		$rs = $this->db->Execute($sql, array($group->id));
		
		switch ($rs->RecordCount()) {
			case 0:
				// There is no-one in this group yet, so don't know which account it is, raise an error
				return false;
				break;
			case 1:
				// One record, good. Send back the root
				$rootID = $rs->FetchNextObj()->rootID;
				break;
			default:
				// Many records means we can't know which root this group belongs to, raise an error
				return false;
		}
		
		// now get the account (just one)
		$accounts = $this->getAccounts(array($rootID));
		return array_shift($accounts);
	}
	
	public function getAccountFromPrefix($prefix) {
	
		$rootID = $this->getAccountRootID($prefix);
		
		// now get the account (just one)
		if ($rootID)
			return array_shift($this->getAccounts(array($rootID)));

        return null;
	}
	
	/**
	 * gh#315 Is there an account linked to an IP in the licence attributes?
	 */
	public function getRootIDFromIP($ip, $productCode = null) {
		// You can match against a complete IP like this:
		//		AND l.F_Value like '%$ip%'
		// But since many are ranges we have to do that in a php loop I think - or could a regex cope?
		$sql = 	<<<EOD
				SELECT l.F_RootID as rootID, l.F_Value as ranges
				FROM T_LicenceAttributes l
				WHERE l.F_Key = 'IPrange'
EOD;
		// gh#723
        // gh#1176 add this link to product code back again
		if ($productCode)
            $sql .= " AND (l.F_ProductCode in ($productCode) OR l.F_ProductCode is null)";

		$rs = $this->db->Execute($sql);
		
		$foundRoots = array();
		if ($rs->RecordCount() > 0) {
			while ($rsObj = $rs->FetchNextObj()) {
				// now simple check to see if the passed ip is in this range
				if ($this->isIPInRange($ip, $rsObj->ranges))
					$foundRoots[] = $rsObj->rootID;
			}
		}
		
		switch (count($foundRoots)) {
			case 0:
				// No such account, quite fine
				return false;
				break;
			case 1:
				// One record, good. Pick up the root
				$rootID = $foundRoots[0];
				break;
			default:
				// Many records means we can't know which root this user belongs to, raise an error
				throw $this->copyOps->getExceptionForId("errorMultipleIPMatches", array("ip" => $ip));
		}
		
		return $rootID;
	}
	/*
	 * Will check if a single, full defined IP matches any range in a list
	 */
	private function isIPInRange($ip, $ipRangeList) {
	 	$ipRangeArray = explode(',', $ipRangeList);
		foreach ($ipRangeArray as $ipRange) {
			$ipRange = trim($ipRange);
			
			// loop through the ip addresses you are running from
		 	$myIpArray = explode(',', $ip);
			foreach ($myIpArray as $myIp) {
				$myIp = trim($myIp);

				// first, is there an exact match?
				if ($myIp == $ipRange)
					return true;
				
				// or does it fall in the range? 
				// assume nnn.nnn.nnn.x-y or nnn.nnn.x-y
				$targetBlocks = explode('.',$ipRange);
				$thisBlocks = explode(".",$myIp);
				// how far down do they specify?
				for ($i=0; $i<count($targetBlocks); $i++) {
					// echo "match ".$thisBlocks[$i]." against ".$targetBlocks[$i]."<br/>";
					if ($targetBlocks[$i] == $thisBlocks[$i]) {
					} else if (strpos($targetBlocks[$i], '-') !== FALSE) {
						$targetArray = explode('-',$targetBlocks[$i]);
						$targetStart = (int) $targetArray[0];
						$targetEnd = (int) $targetArray[1];
						$thisDetail = (int) $thisBlocks[$i];
						if ($targetStart <= $thisDetail && $thisDetail <= $targetEnd) {
							//myTrace("range match " + thisDetail + " between " + targetStart + " and " + targetEnd);
							return true;
						}
					} else {
						//myTrace("no match between " + targetBlocks[i] + " and " + thisBlocks[i]);
						break;
					}
				}
			}
		}
		return false;
	}
	
	/**
	 * Get an account when you know the user
	 */
	public function getAccountFromUser($user) {
		$sql = 	<<<EOD
				SELECT m.F_RootID as rootID
				FROM T_Membership m
				WHERE m.F_UserID = ?
EOD;
		$rs = $this->db->Execute($sql, array($user->id));
		
		switch ($rs->RecordCount()) {
			case 0:
				// No membership record, should be impossible
				return false;
				break;
			case 1:
				// One record, good. Send back the root
				$rootID = $rs->FetchNextObj()->rootID;
				break;
			default:
				// Many records means we can't know which root this user belongs to, raise an error
				return false;
		}
		
		// now get the account (just one)
		$accounts = $this->getAccounts(array($rootID));
		return array_shift($accounts);
	}
	
	/*
	 * Utility function to return the next sequential number for prefixes, (and obfuscate it)
	 */
	public function getNextPrefix() {
		// gh#149
		// gh#884
		$sql = 	<<<EOD
				SELECT MAX(CAST(F_Prefix AS UNSIGNED)) AS MAXPREFIX from T_AccountRoot
				WHERE F_Prefix REGEXP '^[0-9]+$'
EOD;
		//$sql .= NEG_MYPOSTFIX;
		$rs = $this->db->Execute($sql);
		return ((string)((int)($rs->FetchNextObj()->MAXPREFIX) + 1));
	}
	/*
	 * Utility function to get the rootID for a particular prefix
	 */
	public function getAccountRootID($prefix) {
		$lowerCasePrefix = strtolower($prefix);
		$sql = 	<<<EOD
				SELECT F_RootID AS rootID 
				FROM T_AccountRoot
				WHERE LOWER(F_Prefix)='$lowerCasePrefix'
EOD;
		$rs = $this->db->Execute($sql);
		if ($rs) {
			if ($rs->RecordCount() <= 0) {
				$logMessage = 'prefix error 0 record';
				AbstractService::$debugLog->err($logMessage);
			} else {
				return $rs->FetchNextObj()->rootID;
			}
		} else {
			$logMessage = 'prefix error sql, err='.$this->db->ErrorMsg();
			AbstractService::$debugLog->err($logMessage);
		}
	}
}
?>