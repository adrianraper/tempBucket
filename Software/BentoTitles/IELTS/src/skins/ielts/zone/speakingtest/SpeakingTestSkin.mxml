<?xml version="1.0"?>
<s:Skin xmlns:fx="http://ns.adobe.com/mxml/2009"
        xmlns:s="library://ns.adobe.com/flex/spark"
        xmlns:timer="com.clarityenglish.bento.view.timer.*"
        xmlns:components="com.clarityenglish.components.*"
        xmlns:recorder="com.clarityenglish.bento.view.recorder.*"
        xmlns:ui="com.clarityenglish.ielts.view.zone.ui.*"
        xmlns:mx="library://ns.adobe.com/flex/mx"
        creationComplete="onCreationComplete(event)">

    <fx:Metadata>
        [HostComponent("com.clarityenglish.ielts.view.zone.speakingtest.SpeakingTestView")]
    </fx:Metadata>

    <fx:Script>
        <![CDATA[
        import com.clarityenglish.textLayout.components.AudioPlayer;

        import mx.binding.utils.BindingUtils;
        import mx.binding.utils.ChangeWatcher;
        import mx.core.FlexGlobals;
        import mx.events.FlexEvent;

        private var changeWatcher:ChangeWatcher;

        protected function onCreationComplete(event:FlexEvent):void {
            changeWatcher = BindingUtils.bindSetter(onScroll, list.scroller.viewport, "horizontalScrollPosition");
			
			if (list.scroller.horizontalScrollBar)
				list.scroller.horizontalScrollBar.value += (list.scroller.viewport.width * (hostComponent.pageToScroll - 1));
        }

        protected function onScroll(x:* = null):void {
            if (list.scroller.horizontalScrollBar && list.dataProvider) {
                pageNumberDisplay.selectedIndex = Math.floor(list.scroller.horizontalScrollBar.value / list.scroller.viewport.width);
                hostComponent.selectedPageNumber = pageNumberDisplay.selectedIndex;

                if (pageNumberDisplay.selectedIndex == list.dataProvider.length - 1) {
                    rightArrowButton.enabled = false;
                } else if (pageNumberDisplay.selectedIndex == 0) {
                    leftArrowButton.enabled = false;
                    rightArrowButton.enabled = true;
                } else {
                    leftArrowButton.enabled = true;
                    rightArrowButton.enabled = true;
                }
            }
        }

        protected function scrollBy(pages:int):void {
            list.scroller.horizontalScrollBar.value += (list.scroller.viewport.width * pages);
        }

        protected function onRemoveFromStage(event:Event):void {
            if (changeWatcher) changeWatcher.unwatch();
            changeWatcher = null;
        }
        ]]>
    </fx:Script>

    <!-- states -->
    <s:states>
        <s:State name="disabled" />
        <s:State name="normal" />
        
        <s:State name="normalState" />
        <s:State name="testState" />
    </s:states>

    <s:Group top="0" bottom="0" left="0" right="0">
        <s:List id="list" width="514" top="14" bottom="0" horizontalCenter="0" contentBackgroundColor="#FFFFFF" verticalScrollPolicy="off" pageScrollingEnabled="true" scrollSnappingMode="leadingEdge" dataProvider="{hostComponent.testXMLListCollection}" borderVisible="false">
            <s:layout>
                <s:HorizontalLayout gap="0" useVirtualLayout="true" />
            </s:layout>
            <s:itemRenderer>
                <fx:Component>
                    <s:DataRenderer width="514" height="100%" removedFromStage="onRemovedFromStage(event)" creationComplete="onCreationComplete(event)">
                        <fx:Declarations>
                            <s:Parallel id="flipFront" effectStart="onFlipFrontStart(event)" effectEnd="onFlipFrontEnd(event)">
                                <s:Rotate3D target="{frontSwfLoader}"
                                            angleYFrom="0" angleYTo="180" applyLocalProjection="false"
                                            autoCenterTransform="true" autoCenterProjection="true"/>
                                <s:Rotate3D target="{backSwfLoader}"
                                            angleYFrom="180" angleYTo="360" applyLocalProjection="false"
                                            autoCenterTransform="true" autoCenterProjection="true"/>
                                <s:Animate target="{frontSwfLoader}">
                                    <s:SimpleMotionPath property="depth" valueFrom="2" valueTo="0"/>
                                </s:Animate>
                                <s:Animate target="{backSwfLoader}">
                                    <s:SimpleMotionPath property="depth" valueFrom="0" valueTo="2"/>
                                </s:Animate>
                            </s:Parallel>
                            <s:Parallel id="flipFrontReverse">
                                <s:Rotate3D target="{backSwfLoader}"
                                            angleYFrom="360" angleYTo="180" applyLocalProjection="false"
                                            autoCenterTransform="true" autoCenterProjection="true"/>
                                <s:Rotate3D target="{frontSwfLoader}"
                                            angleYFrom="180" angleYTo="0" applyLocalProjection="false"
                                            autoCenterTransform="true" autoCenterProjection="true"/>
                                <s:Animate target="{backSwfLoader}">
                                    <s:SimpleMotionPath property="depth" valueFrom="2" valueTo="0"/>
                                </s:Animate>
                                <s:Animate target="{frontSwfLoader}">
                                    <s:SimpleMotionPath property="depth" valueFrom="0" valueTo="2"/>
                                </s:Animate>
                            </s:Parallel>
                            <s:Parallel id="flipToReflection" effectStart="onFlipToReflectionStart(event)" effectEnd="onFlipToReflectionEnd(event)">
                                <s:Rotate3D target="{backSwfLoader}"
                                            angleYFrom="0" angleYTo="180" applyLocalProjection="false"
                                            autoCenterTransform="true" autoCenterProjection="true"/>
                                <s:Rotate3D target="{reflectionSWFLoader}"
                                            angleYFrom="180" angleYTo="360" applyLocalProjection="false"
                                            autoCenterTransform="true" autoCenterProjection="true"/>
                                <s:Animate target="{backSwfLoader}">
                                    <s:SimpleMotionPath property="depth" valueFrom="2" valueTo="0"/>
                                </s:Animate>
                                <s:Animate target="{reflectionSWFLoader}">
                                    <s:SimpleMotionPath property="depth" valueFrom="0" valueTo="2"/>
                                </s:Animate>
                            </s:Parallel>
                            <s:Parallel id="flipBack" effectStart="onFlipBackStart(event)" effectEnd="onFlipBackEnd(event)">
                                <s:Rotate3D target="{reflectionSWFLoader}"
                                            angleYFrom="0" angleYTo="180" applyLocalProjection="false"
                                            autoCenterTransform="true" autoCenterProjection="true"/>
                                <s:Rotate3D target="{frontSwfLoader}"
                                            angleYFrom="180" angleYTo="360" applyLocalProjection="false"
                                            autoCenterTransform="true" autoCenterProjection="true"/>
                                <s:Animate target="{reflectionSWFLoader}">
                                    <s:SimpleMotionPath property="depth" valueFrom="2" valueTo="0"/>
                                </s:Animate>
                                <s:Animate target="{frontSwfLoader}">
                                    <s:SimpleMotionPath property="depth" valueFrom="0" valueTo="2"/>
                                </s:Animate>
                            </s:Parallel>
                        </fx:Declarations>
                        <fx:Script>
                            <![CDATA[
                            import com.clarityenglish.bento.BentoApplication;
                            import com.clarityenglish.bento.events.ExerciseEvent;
                            import com.clarityenglish.ielts.IELTSApplication;
                            import com.clarityenglish.textLayout.components.AudioPlayer;
                            import com.googlecode.bindagetools.Bind;

                            import flashx.textLayout.container.ScrollPolicy;

                            import mx.binding.utils.ChangeWatcher;
                            import mx.collections.ListCollectionView;
                            import mx.controls.listClasses.BaseListData;
                            import mx.core.UIComponent;

                            import spark.components.List;

                            [Bindable]
                            public var isBackSwfLoaderShow:Boolean;

                            [Bindable]
                            public var isReflectSwfLoaderShow:Boolean;

                            private var changeWatcher:ChangeWatcher;

                            public function onCreationComplete(event:Event):void {
                                Bind.fromProperty(outerDocument.hostComponent, "isReflectionShow").toFunction(function(isReflectionShow:Boolean) {
                                    if (isReflectionShow) {
                                        flipToReflection.play();
                                    }
                                });

                                Bind.fromProperty(outerDocument.hostComponent, "isExitSpeaking").toFunction(function(isExitSpeaking:Boolean) {
                                    if (isExitSpeaking) {
                                        if (isBackSwfLoaderShow) {
                                            isBackSwfLoaderShow = false;
                                            backSwfLoader.visible = false;
                                            flipFrontReverse.play();
                                            dispatchEvent(new Event("backButtonClickEvent", true));
                                            speakingStartButton.visible = true;
                                            speakingBackButton.visible = false;
                                        }

                                        if (isReflectSwfLoaderShow) {
                                            onBackButtonClick();
                                        }
                                    }
                                });
                            }

                            public function getSequenceNumber(data:Object):Number {
                                return (owner as List).dataProvider.getItemIndex(data) + 1;
                            }

                            protected function onRemovedFromStage(event:Event):void {
                                if (changeWatcher) changeWatcher.unwatch();
                                changeWatcher = null;
                            }

                            override public function set data(value:Object):void {
                                super.data = value;

                                if (data) {
                                    var idx:int = ((owner as List).dataProvider as ListCollectionView).getItemIndex(data);
                                    frontSwfLoader.rotationY = 0;
                                    if (outerDocument.hostComponent.isRecordEnabled) {
                                        frontSwfLoader.source = outerDocument.hostComponent.assetFolder + "testpractice_speakingNormalRecordingFront" + (idx + 1) + ".png";
                                    } else {
                                        frontSwfLoader.source = outerDocument.hostComponent.assetFolder + "testpractice_speakingPhoneRecordingFront" + (idx + 1) + ".png";
                                    }
                                    backSwfLoader.source = outerDocument.hostComponent.assetFolder + "testpractice_speakingback" + (idx + 1) + ".png";

                                    // Each item will be rendered only when scroll to it, so we can put initial setting of visibility here.
                                    frontSwfLoader.visible = true;
                                    reflectionSWFLoader.visible = false;
                                    speakingBackButton.visible = false;

                                    speakingStartButton.enabled = !(data.attribute("enabledFlag").length() > 0 && (Number(data.@enabledFlag.toString()) & 8));
                                    frontSwfLoader.alpha = !(data.attribute("enabledFlag").length() > 0 && (Number(data.@enabledFlag.toString()) & 8)) ? 1 : 0.5;

                                    if (data.attribute("enabledFlag").length() > 0 && (Number(data.@enabledFlag.toString()) & 8)) {
                                        speakingStartGroup.toolTip = getToolTip(outerDocument.hostComponent.productVersion, getSequenceNumber(data));
                                    } else {
                                        speakingStartGroup.toolTip = null;
                                    }
                                }
                            }

                            protected function getToolTip(productVersion:String, sequenceNumber:Number = 0):String {
                                switch (productVersion) {
                                    case IELTSApplication.FULL_VERSION:
                                        return outerDocument.hostComponent.getCopyProvider().getCopyForId("notCurAvailable");
                                        break;
                                    case IELTSApplication.LAST_MINUTE:
                                        return outerDocument.hostComponent.getCopyProvider().getCopyForId("onlyAvailableFV");
                                        break;
                                    case IELTSApplication.TEST_DRIVE:
                                        if (sequenceNumber >= 3) {
                                            return outerDocument.hostComponent.getCopyProvider().getCopyForId("onlyAvailableFVWebsite");
                                        }
                                        return outerDocument.hostComponent.getCopyProvider().getCopyForId("onlyAvailableLM");
                                        break;
                                    case BentoApplication.DEMO:
                                        return outerDocument.hostComponent.getCopyProvider().getCopyForId("notAvailbleDemo");
                                        break;
                                    default:
                                        return outerDocument.hostComponent.getCopyProvider().getCopyForId("notAvailble");
                                }
                            }

                            protected function onStartButtonClick(node:XML, attribute:String = "href"):void {
                                AudioPlayer.stopAllAudio();
                                flipFront.play();
                                //dispatchEvent(new Event("startButtonClickEvent", true));
                                dispatchEvent(new ExerciseEvent(ExerciseEvent.EXERCISE_SELECTED, node.@href, node, attribute));
                                speakingStartButton.visible = false;
                            }

                            protected function onBackButtonClick(event:Event = null):void {
                                flipBack.play();
                                dispatchEvent(new Event("backButtonClickEvent", true));
                                speakingStartButton.visible = true;
                                speakingBackButton.visible = false;
                            }

                            protected function onFlipFrontStart(event:Event):void {
                                backSwfLoader.visible = true;
                            }

                            protected function onFlipFrontEnd(event:Event):void {
                                frontSwfLoader.visible = false;
                                isBackSwfLoaderShow = true;
                            }

                            protected function onFlipToReflectionStart(event:Event):void {
                                reflectionSWFLoader.visible = true;
                            }

                            protected function onFlipToReflectionEnd(event:Event):void {
                                speakingBackButton.visible = true;
                                backSwfLoader.visible = false;
                                isReflectSwfLoaderShow = true;
                            }

                            protected function onFlipBackStart(event:Event):void {
                                speakingBackButton.visible = false;
                                frontSwfLoader.visible = true;
                            }

                            protected function onFlipBackEnd(event:Event):void {
                                reflectionSWFLoader.visible = false;
                                isBackSwfLoaderShow = false;
                                isReflectSwfLoaderShow = false;
                            }

                            ]]>
                        </fx:Script>
                        <s:Group id="speakingStartGroup" horizontalCenter="0">
                            <s:Button id="speakingStartButton" top="335" width="452" height="53" horizontalCenter="0" label="{outerDocument.hostComponent.getCopyProvider().getCopyForId('speakingStartButton')}"  click="onStartButtonClick(data as XML)"
                                      useHandCursor="true" buttonMode="true"   />
                        </s:Group>
                        <s:Button id="speakingBackButton" top="{outerDocument.hostComponent.isRecordEnabled? 370 : 335}" width="452" height="45" horizontalCenter="0" label="{outerDocument.hostComponent.getCopyProvider().getCopyForId('speakingBackButton')}" useHandCursor="true" buttonMode="true" click="onBackButtonClick(event)"/>

                        <s:SWFLoader id="reflectionSWFLoader" scaleX="0.5" scaleY="0.5" top="0" horizontalCenter="0" source="{outerDocument.hostComponent.assetFolder + 'testpractice_speakingreflection.png'}" />
                        <s:SWFLoader id="backSwfLoader" scaleX="0.5" scaleY="0.5" top="0" horizontalCenter="0" visible="false" />
                        <s:SWFLoader id="frontSwfLoader" scaleX="0.5" scaleY="0.5" top="0" horizontalCenter="0" />

                        <s:Label id="notAvailableLabel" top="317" horizontalCenter="0" fontSize="16" text="{outerDocument.hostComponent.copyProvider.getCopyForId('notAvailblePracticeTest')}" visible="{(data.attribute('enabledFlag').length() > 0 &amp;&amp; (Number(data.@enabledFlag.toString()) &amp; 8)) &amp;&amp; !outerDocument.hostComponent.isTestDrive}"  />
                        <ui:InfoLabel id="testDriveInfo" verticalCenter="0" horizontalCenter="0" caption="{outerDocument.hostComponent.copyProvider.getCopyForId('exampleInReading')}" visible="{(data.attribute('enabledFlag').length() > 0 &amp;&amp; (Number(data.@enabledFlag.toString()) &amp; 8)) &amp;&amp; outerDocument.hostComponent.isTestDrive}"  />
                    </s:DataRenderer>
                </fx:Component>
            </s:itemRenderer>
        </s:List>

        <s:Group id="actionGroup" width="452" height="40" horizontalCenter="0" bottom="68" includeIn="testState">
            <s:Group id="actionTextGroup" width="100%" height="100%" horizontalCenter="0" verticalCenter="0">
                <s:Rect width="100%" height="100%" radiusX="4" radiusY="4">
                    <s:fill>
                        <s:SolidColor color="#A93087" />
                    </s:fill>
                </s:Rect>
                <s:Label id="planningLabel" horizontalCenter="0" verticalCenter="0" color="#FFFFFF" />
                <s:Label id="recordingLabel" horizontalCenter="0" verticalCenter="0" color="#FFFFFF" />
                <s:Label id="completeLabel" horizontalCenter="0" verticalCenter="0" color="#FFFFFF" />
            </s:Group>
            <s:Group id="recorderGroup" width="100%" height="100%" verticalCenter="0">
                <!--recorder:RecorderView id="recorderView" left="0" right="0" top="0" bottom="0" /-->
            </s:Group>
        </s:Group>

        <s:Group id="timerGroup" width="100%" top="0" bottom="0" left="1" right="1" excludeFrom="normalState">
            <timer:TimerComponent id="timer" bottom="0"
                                  timerTotalTime="{String(hostComponent.testXML.attribute('totalTime')).split(',')}"
                                  timerSectionLabels="{String(hostComponent.testXML.attribute('timerSectionLabels')).split(',')}"
                                  audios="{String(hostComponent.testXML.attribute('audios')).split(',')}"
                                  copyProvider="{hostComponent.getCopyProvider()}"
                                  contentPath="{hostComponent.href.rootPath}" textSize="17" timeTextColor="#333333"
                                  trackColor="#D8D8D8" trackHighLightColor="#A8A8A8" progressLeftColor="#A93087"
                                  progressMidColor="#A93087" progressRightColor="#A93087" buttonColor="#A93087"
                                  buttonDownOverColor="#4F173F"
                                  firstTipString="{hostComponent.getCopyProvider().getCopyForId('timerFirstTipString')}"
                                  midTipString="{hostComponent.getCopyProvider().getCopyForId('timerMidTipString')}"
                                  timerWidth="380" timerHeight="24" width="100%" height="60"
                                  isTimeFixed="true" isTimerAutoControl="true"
                                  isPlatformTablet="{hostComponent.isPlatformTablet}"/>
        </s:Group>

        <components:PageNumberDisplay id="pageNumberDisplay" horizontalCenter="0" bottom="15" dataProvider="{list.dataProvider}" includeIn="normalState" />
        <s:Button id="leftArrowButton" click="scrollBy(-1)" visible="{getStyle('showArrows')}" left="5" top="160" mouseEnabled="true" buttonMode="true" includeIn="normalState" enabled="false" />
        <s:Button id="rightArrowButton" click="scrollBy(1)" visible="{getStyle('showArrows')}" right="5" top="165" mouseEnabled="true" buttonMode="true" includeIn="normalState" />
    </s:Group>
</s:Skin>
