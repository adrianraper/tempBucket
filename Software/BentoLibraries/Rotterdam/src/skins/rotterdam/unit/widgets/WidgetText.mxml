<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx"
		 xmlns:components="com.clarityenglish.components.*">
	
	<fx:Script>
		<![CDATA[
			import com.clarityenglish.rotterdam.view.unit.events.WidgetLinkCaptureEvent;
			import com.clarityenglish.rotterdam.view.unit.events.WidgetTextFormatMenuEvent;
			import com.clarityenglish.rotterdam.view.unit.widgets.AbstractWidget;
			import com.googlecode.bindagetools.Bind;
			
			import flash.text.engine.TextElement;
			
			import flashx.textLayout.compose.FlowComposerBase;
			import flashx.textLayout.compose.FlowDamageType;
			import flashx.textLayout.conversion.ConversionType;
			import flashx.textLayout.conversion.TextConverter;
			import flashx.textLayout.elements.FlowElement;
			import flashx.textLayout.elements.FlowGroupElement;
			import flashx.textLayout.elements.FlowLeafElement;
			import flashx.textLayout.elements.LinkElement;
			import flashx.textLayout.elements.ParagraphElement;
			import flashx.textLayout.elements.SpanElement;
			import flashx.textLayout.elements.TextFlow;
			import flashx.textLayout.formats.TextLayoutFormat;
			
			import mx.collections.XMLListCollection;
			import mx.events.FlexEvent;
			
			import org.davekeen.util.XmlUtils;
			
			import spark.utils.TextFlowUtil;
			
			private var _widget:AbstractWidget;
			
			private var _editing:Boolean;
			
			[Bindable]
			public function get widget():AbstractWidget {
				return _widget;
			}

			public function set widget(value:AbstractWidget):void {
				_widget = value;
				
				Bind.fromProperty(widget, "text")
					.convert(function(value:Object):Object {
						var xml:XML = XmlUtils.preserveSpaces(function():XML { return new XML(value) } ); // gh#235
						return TextConverter.importToFlow(xml, TextConverter.TEXT_LAYOUT_FORMAT);
					}).toProperty(richEditableText, "textFlow");
			}

			public function set editing(value:Boolean):void {
				if (_editing !== value) {
					_editing = value;
					setCurrentState((value) ? "editing" : "normal");
				}
			}
			
			public function get editing():Boolean {
				return _editing;
			}
			
			protected function onValueCommit(event:FlexEvent):void {
				widget.text = TextConverter.export(event.target.textFlow, TextConverter.TEXT_LAYOUT_FORMAT, ConversionType.STRING_TYPE).toString();
			}
			
			public function applyTextLayoutFormat(format:TextLayoutFormat):void {
				var selectionAnchorPosition:int = richEditableText.selectionAnchorPosition;
				var selectionActivePosition:int = richEditableText.selectionActivePosition;
				
				richEditableText.setFormatOfRange(format, selectionAnchorPosition, selectionActivePosition);
				
				// Set the focus and selection back to the text component
				richEditableText.setFocus();
				richEditableText.selectRange(selectionAnchorPosition, selectionActivePosition);
			}
			
			public function addLink(webUrlString:String, captionString:String):void {
				var anchorPosition:int = Math.min(richEditableText.selectionAnchorPosition, richEditableText.selectionActivePosition);
				var activePosition:int = Math.max(richEditableText.selectionAnchorPosition, richEditableText.selectionActivePosition);
				//alice: solve the problem when add link in an empty text box (activePosition=-1 anchorPosition=-1)
				if (anchorPosition == activePosition && activePosition == -1)
					anchorPosition = activePosition = 0;

				// gh#896 Allow any valid protocol
				var urlPattern:RegExp = /([\w]+?):\/\/([^:\/]+)(:\d+)?\//ig;
				var matches:Array = webUrlString.match(urlPattern);
				if (matches && matches.length == 0)
					webUrlString = "http://" + webUrlString;
				
				XmlUtils.preserveSpaces(function():void {	
					if (anchorPosition == 0 && activePosition == 0) {
						var anchorTag:XML = <a href={webUrlString} target="_blank">{captionString}</a>;
						var textFlow:TextFlow = TextConverter.importToFlow(widget.text, TextConverter.TEXT_LAYOUT_FORMAT) || new TextFlow();				
						var textXML:XML = TextConverter.export(textFlow, TextConverter.TEXT_LAYOUT_FORMAT, ConversionType.XML_TYPE) as XML;
						
						// gh#221 enable web link insert next to text
						if (textXML == "") {
							textXML.appendChild(anchorTag);
						} else if (textXML.children().children() == "") {
							textXML.children().appendChild(anchorTag);
						} else {
							textXML.children()[textXML.children().length()-1].appendChild(anchorTag);
						}
						widget.text = textXML.toXMLString();
						
					} else {
						var richTextFlow:TextFlow = richEditableText.textFlow;
						var lastFlowElement:TextFlow = richTextFlow.splitAtPosition(activePosition) as TextFlow;
						var chopFlowElment:TextFlow = richTextFlow.splitAtPosition(anchorPosition) as TextFlow;

						if (richTextFlow.numChildren > 0) {
							var firstParagraph:ParagraphElement= richTextFlow.getChildAt(richTextFlow.numChildren -1) as ParagraphElement;
						} else {
							firstParagraph = new ParagraphElement();
						}				
						
						// gh#320
						var chopLastElement:FlowElement = chopFlowElment.getLastLeaf() as FlowElement;
						if (chopLastElement.parent is LinkElement && webUrlString == "") {
							var spanElement:SpanElement = new SpanElement();
							spanElement.text = captionString;
							
							if (firstParagraph) {
								firstParagraph.addChild(spanElement);
								var lastP:ParagraphElement = lastFlowElement.getChildAt(0) as ParagraphElement;					
								if (lastP)
									firstParagraph.replaceChildren(firstParagraph.numChildren, firstParagraph.numChildren, getParagraphChildren(lastP));
							}
							
						} else {
							var linkElement:LinkElement = new LinkElement();
							linkElement.href = webUrlString;
							linkElement.target = "_blank";
							var linkSpan:SpanElement = new SpanElement();
							linkSpan.text = captionString;
							linkElement.addChild(linkSpan);
							
							if (firstParagraph) {
								firstParagraph.addChild(linkElement);
								lastP = lastFlowElement.getChildAt(0) as ParagraphElement;					
								if (lastP)
									firstParagraph.replaceChildren(firstParagraph.numChildren, firstParagraph.numChildren, getParagraphChildren(lastP));
							}
						}
						
						// Delete the last child in first part and add new selected child, then merge with last part
						if (richTextFlow.numChildren > 0)
							richTextFlow.removeChildAt(richTextFlow.numChildren - 1);
						richTextFlow.addChild(firstParagraph);
						var totalNumber:Number = lastFlowElement.numChildren;
						for (var i:int = 1; i < totalNumber; i++ ) {
							var paragraphElement:ParagraphElement = lastFlowElement.getChildAt(1) as ParagraphElement;
							richTextFlow.addChild(paragraphElement);
						}
						
						var	firstXML:XML = TextConverter.export(richTextFlow, TextConverter.TEXT_LAYOUT_FORMAT, ConversionType.XML_TYPE) as XML;
						widget.text = firstXML.toString();
					}});
			}
					
			private function getParagraphChildren(p:ParagraphElement):Array {
				var kids:Array =[];
				var numKids:int = p.numChildren;
				for (var i:int = 0; i<numKids; i++) 
					kids.push(p.getChildAt(i));
				return kids;
			}
			
			protected function onSelectionChange(event:FlexEvent):void {
				var selectionAnchorPosition:Number = Math.min(richEditableText.selectionAnchorPosition, richEditableText.selectionActivePosition);
				var selectionActivePosition:Number = Math.max(richEditableText.selectionAnchorPosition, richEditableText.selectionActivePosition);
				if (richEditableText.text != "") { // this check stops an exception in the TLF related to gh#160 when clicking around very fast
					var format:TextLayoutFormat = richEditableText.getFormatOfRange(null, selectionAnchorPosition, selectionActivePosition);
					dispatchEvent(new WidgetTextFormatMenuEvent(WidgetTextFormatMenuEvent.TEXT_SELECTED, false, format));
					
					var caption:String = richEditableText.text.substring(richEditableText.selectionAnchorPosition, richEditableText.selectionActivePosition);
					
					// gh#320
					var urlTextFlow:TextFlow = richEditableText.textFlow;
					var urlTextFlowElement:FlowElement = urlTextFlow.findLeaf(selectionAnchorPosition) as FlowElement;				
					if (urlTextFlowElement.parent is LinkElement) {
						var linkElement:LinkElement = urlTextFlowElement.parent as LinkElement;
						var urlString:String = linkElement.href;
					}

					dispatchEvent(new WidgetLinkCaptureEvent(WidgetLinkCaptureEvent.CAPTION_SELECTED, false, caption, urlString));
				}
			}
			
		]]>
	</fx:Script>
	
	<s:states>
		<s:State name="normal" />
		<s:State name="editing" />
	</s:states>
	
	<s:Rect id="focusHighlight" left="0" right="0" top="0" bottom="0" radiusX="4" radiusY="4" visible="false">
		<s:stroke>
			<s:SolidColorStroke color="#DAC350" />
		</s:stroke>
		<s:fill>
			<s:SolidColor color="#FFF9DB" />
		</s:fill>
	</s:Rect>
	
	<!-- gh#389 selectable is always true -->
<<<<<<< HEAD
	<!-- gh#1061 -->
=======
>>>>>>> 0208921... fixed #389
	<components:PromptingRichEditableText id="richEditableText"
										  placeholder="{widget.placeholder}"
										  left="8" right="8" top="8" minHeight="{minHeight}"
										  backgroundAlpha="0" focusSkin="{null}" 
										  editable.normal="false" editable.editing="true"
										  selectable="true"
										  valueCommit="onValueCommit(event)"
										  selectionChange="onSelectionChange(event)"
										  focusIn.editing="focusHighlight.visible = true"
										  focusOut.editing="focusHighlight.visible = false" whiteSpaceCollapse="preserve"/>	
</s:Group>
