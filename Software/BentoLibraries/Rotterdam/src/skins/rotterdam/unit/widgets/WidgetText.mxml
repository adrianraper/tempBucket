<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx"
		 xmlns:components="com.clarityenglish.components.*">
	
	<fx:Script>
		<![CDATA[
			import com.clarityenglish.rotterdam.view.unit.events.WidgetLinkCaptureEvent;
			import com.clarityenglish.rotterdam.view.unit.events.WidgetTextFormatMenuEvent;
			import com.clarityenglish.rotterdam.view.unit.widgets.AbstractWidget;
			import com.googlecode.bindagetools.Bind;
			
			import flashx.textLayout.conversion.ConversionType;
			import flashx.textLayout.conversion.TextConverter;
			import flashx.textLayout.elements.FlowElement;
			import flashx.textLayout.elements.LinkElement;
			import flashx.textLayout.elements.ParagraphElement;
			import flashx.textLayout.elements.SpanElement;
			import flashx.textLayout.elements.TextFlow;
			import flashx.textLayout.formats.TextLayoutFormat;
			
			import mx.events.FlexEvent;
			
			import org.davekeen.util.XmlUtils;
			
			private var _widget:AbstractWidget;
			
			private var _editing:Boolean;
			
			[Bindable]
			public function get widget():AbstractWidget {
				return _widget;
			}

			public function set widget(value:AbstractWidget):void {
				_widget = value;
				
				Bind.fromProperty(widget, "text")
					.convert(function(value:Object):Object {
						var xml:XML = XmlUtils.preserveSpaces(function():XML { return new XML(value) } ); // gh#235
						return TextConverter.importToFlow(xml, TextConverter.TEXT_LAYOUT_FORMAT);
					}).toProperty(richEditableText, "textFlow");
			}

			public function set editing(value:Boolean):void {
				if (_editing !== value) {
					_editing = value;
					setCurrentState((value) ? "editing" : "normal");
				}
			}
			
			public function get editing():Boolean {
				return _editing;
			}
			
			protected function onValueCommit(event:FlexEvent):void {
				widget.text = TextConverter.export(event.target.textFlow, TextConverter.TEXT_LAYOUT_FORMAT, ConversionType.STRING_TYPE).toString();
			}
			
			public function applyTextLayoutFormat(format:TextLayoutFormat):void {
				var selectionAnchorPosition:int = richEditableText.selectionAnchorPosition;
				var selectionActivePosition:int = richEditableText.selectionActivePosition;
				
				richEditableText.setFormatOfRange(format, selectionAnchorPosition, selectionActivePosition);
				
				// Set the focus and selection back to the text component
				richEditableText.setFocus();
				richEditableText.selectRange(selectionAnchorPosition, selectionActivePosition);
			}
			
			public function AddLink(webUrlString:String, captionString:String):void {
				var anchorPosition:int = Math.min(richEditableText.selectionAnchorPosition, richEditableText.selectionActivePosition);
				var activePosition:int = Math.max(richEditableText.selectionAnchorPosition, richEditableText.selectionActivePosition);
				//alice: solve the problem when add link in an empty text box (activePosition=-1 anchorPosition=-1)
				if (anchorPosition == activePosition && activePosition == -1) {
					anchorPosition = 0;
					activePosition = 0;
				}
				
				if (webUrlString.search("http://") == -1) {
					webUrlString = "http://" + webUrlString;
				}

				XmlUtils.preserveSpaces(function():void {	
					if (anchorPosition == 0 && activePosition == 0) {
						var anchorTag:XML = <a href={webUrlString} target="_blank">{captionString}</a>;
						var textFlow:TextFlow = TextConverter.importToFlow(widget.text, TextConverter.TEXT_LAYOUT_FORMAT) || new TextFlow();				
						var textXML:XML = TextConverter.export(textFlow, TextConverter.TEXT_LAYOUT_FORMAT, ConversionType.XML_TYPE) as XML;
						
						//gh#221: enalbe web link insert next to text
						if (textXML == "") {
							textXML.appendChild(anchorTag);
						}
						else if (textXML.children().children() == "") {
							textXML.children().appendChild(anchorTag);
						} else {
							textXML.children()[textXML.children().length()-1].appendChild(anchorTag);
						}
						widget.text = textXML.toXMLString();
					} else {
						var richTextFlow:TextFlow = richEditableText.textFlow;
						var lastFlowElment:TextFlow = richTextFlow.splitAtPosition(activePosition) as TextFlow;
						var chopFlowElment:FlowElement = richTextFlow.splitAtPosition(anchorPosition)
						if (richTextFlow.numChildren > 0) {
							var firstParagraph:ParagraphElement= richTextFlow.getChildAt(richTextFlow.numChildren -1) as ParagraphElement;
						} else {
							firstParagraph = new ParagraphElement();
						}				
						
						//insert link element
						var linkElement:LinkElement = new LinkElement();
						linkElement.href = webUrlString;
						linkElement.target = "_blank";
						var linkSpan:SpanElement = new SpanElement();
						linkSpan.text = captionString;
						linkElement.addChild(linkSpan);
						if (firstParagraph) {
							firstParagraph.addChild(linkElement);
							var lastP:ParagraphElement = lastFlowElment.getChildAt(0) as ParagraphElement;					
							if (lastP) {
								firstParagraph.replaceChildren(firstParagraph.numChildren, firstParagraph.numChildren, getParagraphChildren(lastP));
							}
						}
						
						//Delete the last child in first part and add new selected child, then merge with last part
						if (richTextFlow.numChildren > 0) {
							richTextFlow.removeChildAt(richTextFlow.numChildren - 1);
						}			
						richTextFlow.addChild(firstParagraph);
						var totalNumber:Number = lastFlowElment.numChildren;
						for (var i:int = 1; i < totalNumber; i++ ) {
							var paragraphElement:ParagraphElement = lastFlowElment.getChildAt(1) as ParagraphElement;
							richTextFlow.addChild(paragraphElement);
						}
						
						var	firstXML:XML = TextConverter.export(richTextFlow, TextConverter.TEXT_LAYOUT_FORMAT, ConversionType.XML_TYPE) as XML;
						widget.text = firstXML.toString();
					}});
			}
					
			private function getParagraphChildren(p:ParagraphElement):Array
			{
				var kids:Array =[];
				var numKids:int = p.numChildren;
				for (var i:int = 0; i<numKids; i++)
				{
					kids.push( p.getChildAt(i) );
				}
				return kids;
			}
			
			protected function onSelectionChange(event:FlexEvent):void {
				if (richEditableText.text != "") { // this check stops an exception in the TLF related to gh#160 when clicking around very fast
					var format:TextLayoutFormat = richEditableText.getFormatOfRange(null, richEditableText.selectionAnchorPosition, richEditableText.selectionActivePosition);
					dispatchEvent(new WidgetTextFormatMenuEvent(WidgetTextFormatMenuEvent.TEXT_SELECTED, false, format));
					
					var caption:String = richEditableText.text.substring(richEditableText.selectionAnchorPosition, richEditableText.selectionActivePosition);
					dispatchEvent(new WidgetLinkCaptureEvent(WidgetLinkCaptureEvent.CAPTION_SELECTED, false, caption));
				}
			}
			
		]]>
	</fx:Script>
	
	<s:states>
		<s:State name="normal" />
		<s:State name="editing" />
	</s:states>
	
	<s:Rect id="focusHighlight" left="0" right="0" top="0" bottom="0" radiusX="4" radiusY="4" visible="false">
		<s:stroke>
			<s:SolidColorStroke color="#DAC350" />
		</s:stroke>
		<s:fill>
			<s:SolidColor color="#FFF9DB" />
		</s:fill>
	</s:Rect>
	
	<components:PromptingRichEditableText id="richEditableText"
										  placeholder="{widget.placeholder}"
										  left="8" right="8" top="8" minHeight="{minHeight}"
										  fontFamily="Helvetica" fontSize="13"
										  backgroundAlpha="0" focusSkin="{null}" 
										  editable.normal="false" editable.editing="true"
										  selectable.normal="false" selectable.editing="true"
										  valueCommit="onValueCommit(event)"
										  selectionChange="onSelectionChange(event)"
										  focusIn.editing="focusHighlight.visible = true"
										  focusOut.editing="focusHighlight.visible = false" whiteSpaceCollapse="preserve"/>	
</s:Group>
